/**
 * Generated by orval v8.0.0-rc.0 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from '../lib/api-mutator';
export interface UserUpdateDto {
  /**
   * @minLength 0
   * @maxLength 100
   */
  username: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  email: string;
  /**
   * @minLength 0
   * @maxLength 50
   */
  role: string;
}

export interface UserResponseDto {
  id?: number;
  username?: string;
  email?: string;
  role?: string;
  createdAt?: string;
}

export interface EventUpdateDto {
  /**
   * @minLength 0
   * @maxLength 255
   */
  title: string;
  /**
   * @minLength 0
   * @maxLength 1000
   */
  description?: string;
  startTime?: string;
  endTime?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  venue?: string;
}

export interface EventResponseDto {
  id?: number;
  title?: string;
  description?: string;
  startTime?: string;
  endTime?: string;
  venue?: string;
  createdAt?: string;
}

export interface UserCreateDto {
  /**
   * @minLength 0
   * @maxLength 100
   */
  username: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  email: string;
  /**
   * @minLength 0
   * @maxLength 50
   */
  role: string;
}

export interface EventCreateDto {
  /**
   * @minLength 0
   * @maxLength 255
   */
  title: string;
  /**
   * @minLength 0
   * @maxLength 1000
   */
  description?: string;
  startTime?: string;
  endTime?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  venue?: string;
}

export interface PageUserResponseDto {
  totalElements?: number;
  totalPages?: number;
  first?: boolean;
  last?: boolean;
  size?: number;
  content?: UserResponseDto[];
  number?: number;
  sort?: SortObject[];
  numberOfElements?: number;
  pageable?: PageableObject;
  empty?: boolean;
}

export interface PageableObject {
  offset?: number;
  sort?: SortObject[];
  unpaged?: boolean;
  pageNumber?: number;
  pageSize?: number;
  paged?: boolean;
}

export interface SortObject {
  direction?: string;
  nullHandling?: string;
  ascending?: boolean;
  property?: string;
  ignoreCase?: boolean;
}

export interface PageEventResponseDto {
  totalElements?: number;
  totalPages?: number;
  first?: boolean;
  last?: boolean;
  size?: number;
  content?: EventResponseDto[];
  number?: number;
  sort?: SortObject[];
  numberOfElements?: number;
  pageable?: PageableObject;
  empty?: boolean;
}

export type ListParams = {
/**
 * Zero-based page index (0..N)
 * @minimum 0
 */
page?: number;
/**
 * The size of the page to be returned
 * @minimum 1
 */
size?: number;
/**
 * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 */
sort?: string[];
};

export type List1Params = {
/**
 * Zero-based page index (0..N)
 * @minimum 0
 */
page?: number;
/**
 * The size of the page to be returned
 * @minimum 1
 */
size?: number;
/**
 * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
 */
sort?: string[];
};

export type getResponse200 = {
  data: UserResponseDto
  status: 200
}
    
export type getResponseSuccess = (getResponse200) & {
  headers: Headers;
};
;

export type getResponse = (getResponseSuccess)

export const getGetUrl = (id: number,) => {


  

  return `/api/users/${id}`
}

export const get = async (id: number, options?: RequestInit): Promise<getResponse> => {
  
  return customInstance<getResponse>(getGetUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetQueryKey = (id?: number,) => {
    return [
    `/api/users/${id}`
    ] as const;
    }

    
export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & { queryKey: QueryKey }
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = unknown



export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateResponse200 = {
  data: UserResponseDto
  status: 200
}
    
export type updateResponseSuccess = (updateResponse200) & {
  headers: Headers;
};
;

export type updateResponse = (updateResponseSuccess)

export const getUpdateUrl = (id: number,) => {


  

  return `/api/users/${id}`
}

export const update = async (id: number,
    userUpdateDto: UserUpdateDto, options?: RequestInit): Promise<updateResponse> => {
  
  return customInstance<updateResponse>(getUpdateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userUpdateDto,)
  }
);}




export const getUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: UserUpdateDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: UserUpdateDto}, TContext> => {

const mutationKey = ['update'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof update>>, {id: number;data: UserUpdateDto}> = (props) => {
          const {id,data} = props ?? {};

          return  update(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMutationResult = NonNullable<Awaited<ReturnType<typeof update>>>
    export type UpdateMutationBody = UserUpdateDto
    export type UpdateMutationError = unknown

    export const useUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: UserUpdateDto}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof update>>,
        TError,
        {id: number;data: UserUpdateDto},
        TContext
      > => {

      const mutationOptions = getUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type _deleteResponse204 = {
  data: void
  status: 204
}
    
export type _deleteResponseSuccess = (_deleteResponse204) & {
  headers: Headers;
};
;

export type _deleteResponse = (_deleteResponseSuccess)

export const getDeleteUrl = (id: number,) => {


  

  return `/api/users/${id}`
}

export const _delete = async (id: number, options?: RequestInit): Promise<_deleteResponse> => {
  
  return customInstance<_deleteResponse>(getDeleteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext> => {

const mutationKey = ['_delete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof _delete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  _delete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type _DeleteMutationResult = NonNullable<Awaited<ReturnType<typeof _delete>>>
    
    export type _DeleteMutationError = unknown

    export const useDelete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof _delete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type get1Response200 = {
  data: EventResponseDto
  status: 200
}
    
export type get1ResponseSuccess = (get1Response200) & {
  headers: Headers;
};
;

export type get1Response = (get1ResponseSuccess)

export const getGet1Url = (id: number,) => {


  

  return `/api/events/${id}`
}

export const get1 = async (id: number, options?: RequestInit): Promise<get1Response> => {
  
  return customInstance<get1Response>(getGet1Url(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGet1QueryKey = (id?: number,) => {
    return [
    `/api/events/${id}`
    ] as const;
    }

    
export const getGet1QueryOptions = <TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGet1QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get1>>> = ({ signal }) => get1(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData> & { queryKey: QueryKey }
}

export type Get1QueryResult = NonNullable<Awaited<ReturnType<typeof get1>>>
export type Get1QueryError = unknown



export function useGet1<TData = Awaited<ReturnType<typeof get1>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get1>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGet1QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type update1Response200 = {
  data: EventResponseDto
  status: 200
}
    
export type update1ResponseSuccess = (update1Response200) & {
  headers: Headers;
};
;

export type update1Response = (update1ResponseSuccess)

export const getUpdate1Url = (id: number,) => {


  

  return `/api/events/${id}`
}

export const update1 = async (id: number,
    eventUpdateDto: EventUpdateDto, options?: RequestInit): Promise<update1Response> => {
  
  return customInstance<update1Response>(getUpdate1Url(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eventUpdateDto,)
  }
);}




export const getUpdate1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update1>>, TError,{id: number;data: EventUpdateDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof update1>>, TError,{id: number;data: EventUpdateDto}, TContext> => {

const mutationKey = ['update1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof update1>>, {id: number;data: EventUpdateDto}> = (props) => {
          const {id,data} = props ?? {};

          return  update1(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Update1MutationResult = NonNullable<Awaited<ReturnType<typeof update1>>>
    export type Update1MutationBody = EventUpdateDto
    export type Update1MutationError = unknown

    export const useUpdate1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update1>>, TError,{id: number;data: EventUpdateDto}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof update1>>,
        TError,
        {id: number;data: EventUpdateDto},
        TContext
      > => {

      const mutationOptions = getUpdate1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type delete1Response204 = {
  data: void
  status: 204
}
    
export type delete1ResponseSuccess = (delete1Response204) & {
  headers: Headers;
};
;

export type delete1Response = (delete1ResponseSuccess)

export const getDelete1Url = (id: number,) => {


  

  return `/api/events/${id}`
}

export const delete1 = async (id: number, options?: RequestInit): Promise<delete1Response> => {
  
  return customInstance<delete1Response>(getDelete1Url(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDelete1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof delete1>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof delete1>>, TError,{id: number}, TContext> => {

const mutationKey = ['delete1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof delete1>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  delete1(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Delete1MutationResult = NonNullable<Awaited<ReturnType<typeof delete1>>>
    
    export type Delete1MutationError = unknown

    export const useDelete1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof delete1>>, TError,{id: number}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof delete1>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDelete1MutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type listResponse200 = {
  data: PageUserResponseDto
  status: 200
}
    
export type listResponseSuccess = (listResponse200) & {
  headers: Headers;
};
;

export type listResponse = (listResponseSuccess)

export const getListUrl = (params?: ListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/users?${stringifiedParams}` : `/api/users`
}

export const list = async (params?: ListParams, options?: RequestInit): Promise<listResponse> => {
  
  return customInstance<listResponse>(getListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListQueryKey = (params?: ListParams,) => {
    return [
    `/api/users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListQueryOptions = <TData = Awaited<ReturnType<typeof list>>, TError = unknown>(params?: ListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof list>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof list>>> = ({ signal }) => list(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof list>>, TError, TData> & { queryKey: QueryKey }
}

export type ListQueryResult = NonNullable<Awaited<ReturnType<typeof list>>>
export type ListQueryError = unknown



export function useList<TData = Awaited<ReturnType<typeof list>>, TError = unknown>(
 params?: ListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof list>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createResponse201 = {
  data: UserResponseDto
  status: 201
}
    
export type createResponseSuccess = (createResponse201) & {
  headers: Headers;
};
;

export type createResponse = (createResponseSuccess)

export const getCreateUrl = () => {


  

  return `/api/users`
}

export const create = async (userCreateDto: UserCreateDto, options?: RequestInit): Promise<createResponse> => {
  
  return customInstance<createResponse>(getCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userCreateDto,)
  }
);}




export const getCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: UserCreateDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: UserCreateDto}, TContext> => {

const mutationKey = ['create'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, {data: UserCreateDto}> = (props) => {
          const {data} = props ?? {};

          return  create(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>
    export type CreateMutationBody = UserCreateDto
    export type CreateMutationError = unknown

    export const useCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: UserCreateDto}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof create>>,
        TError,
        {data: UserCreateDto},
        TContext
      > => {

      const mutationOptions = getCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type list1Response200 = {
  data: PageEventResponseDto
  status: 200
}
    
export type list1ResponseSuccess = (list1Response200) & {
  headers: Headers;
};
;

export type list1Response = (list1ResponseSuccess)

export const getList1Url = (params?: List1Params,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/events?${stringifiedParams}` : `/api/events`
}

export const list1 = async (params?: List1Params, options?: RequestInit): Promise<list1Response> => {
  
  return customInstance<list1Response>(getList1Url(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getList1QueryKey = (params?: List1Params,) => {
    return [
    `/api/events`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getList1QueryOptions = <TData = Awaited<ReturnType<typeof list1>>, TError = unknown>(params?: List1Params, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof list1>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getList1QueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof list1>>> = ({ signal }) => list1(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof list1>>, TError, TData> & { queryKey: QueryKey }
}

export type List1QueryResult = NonNullable<Awaited<ReturnType<typeof list1>>>
export type List1QueryError = unknown



export function useList1<TData = Awaited<ReturnType<typeof list1>>, TError = unknown>(
 params?: List1Params, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof list1>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getList1QueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type create1Response201 = {
  data: EventResponseDto
  status: 201
}
    
export type create1ResponseSuccess = (create1Response201) & {
  headers: Headers;
};
;

export type create1Response = (create1ResponseSuccess)

export const getCreate1Url = () => {


  

  return `/api/events`
}

export const create1 = async (eventCreateDto: EventCreateDto, options?: RequestInit): Promise<create1Response> => {
  
  return customInstance<create1Response>(getCreate1Url(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      eventCreateDto,)
  }
);}




export const getCreate1MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create1>>, TError,{data: EventCreateDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof create1>>, TError,{data: EventCreateDto}, TContext> => {

const mutationKey = ['create1'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof create1>>, {data: EventCreateDto}> = (props) => {
          const {data} = props ?? {};

          return  create1(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type Create1MutationResult = NonNullable<Awaited<ReturnType<typeof create1>>>
    export type Create1MutationBody = EventCreateDto
    export type Create1MutationError = unknown

    export const useCreate1 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create1>>, TError,{data: EventCreateDto}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof create1>>,
        TError,
        {data: EventCreateDto},
        TContext
      > => {

      const mutationOptions = getCreate1MutationOptions(options);

      return useMutation(mutationOptions);
    }
